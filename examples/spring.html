<html>

  <head>
    <style>
      #container{ position:absolute; left:0px; top:0px; }
      body{ margin:0px; }
    </style>
  </head>

  <body>

    <script src="../lib/three.js"></script>
    <script src="../lib/jquery.min.js"></script>
    <script src="../lib/TrackballControls.js"></script>
    <script src="../lib/ShaderLoader.js"></script>
    
    <script src="../ParticleUtils.js"></script>
    <script src="../PhysicsRenderer.js"></script>

    <script>


      var paused = false;


      var camera, renderer, scene , controls , clock;
      
      var particleSystem;
      var physicsRenderer , uniforms;

      var leader;

      var dT = { type:"f" , value:0 }

      var timer = 0;
      // Using: https://github.com/cabbibo/ShaderLoader
      // For More info: http://cabbibo.github.io/ShaderLoader/

      var shaders = new ShaderLoader('../shaders');

      shaders.shaderSetLoaded = function(){
        init();
        animate();
      }

      shaders.load( 'fs-spring' , 'render'  , 'fragment'    );
      shaders.load( 'vs-render' , 'render'  , 'vertex'      );
      shaders.load( 'tailSim'   , 'tailSim' , 'simulation'  );
      shaders.load( 'fs-lineRender' , 'lineRender' , 'fragment' );
      shaders.load( 'vs-lineRender' , 'lineRender' , 'vertex' );


      function init(){

        /*

          THREE.js Initialization

        */

        var w = window.innerWidth;
        var h = window.innerHeight;

        camera = new THREE.PerspectiveCamera( 65 , w/h , 1 , 200000 );
        camera.position.z = 100;

        controls = new THREE.TrackballControls( camera );
        scene = new THREE.Scene();

        clock = new THREE.Clock();


        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        document.body.appendChild( renderer.domElement );

        size = 32;

        var sim = shaders.simulationShaders.tailSim;
        physicsRenderer = new PhysicsRenderer( size , sim , renderer ); 

        leader = new THREE.Vector3();

        var mesh = new THREE.Mesh(
          new THREE.IcosahedronGeometry( .5 , 1 ),
          new THREE.MeshNormalMaterial()
        );

        mesh.position = leader;
        scene.add( mesh );


        var leaderU = { type:"v3" , value: leader } 
        physicsRenderer.setUniform( 'leader' , leaderU );
        physicsRenderer.setUniform( 'dT' , dT );
        
        
        uniforms = {
          t_pos:{ type:"t" , value:null },
          t_oPos:{ type:"t" , value:null },
          t_ooPos:{ type:"t" , value:null },
        }

        var mat = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: shaders.vertexShaders.render,
          fragmentShader: shaders.fragmentShaders.render
        })

        var geo = ParticleUtils.createLookupGeometry( size );

        physicsParticles  = new THREE.ParticleSystem( geo , mat );

        physicsRenderer.addBoundTexture( physicsParticles , 't_pos' , 'output' );
        physicsRenderer.addBoundTexture( physicsParticles , 't_oPos' , 'oOutput' );
        physicsRenderer.addBoundTexture( physicsParticles , 't_ooPos' , 'ooOutput' );

        scene.add( physicsParticles );

        var mesh = new THREE.Mesh( new THREE.SphereGeometry( 5 ) );

        var pTexture = ParticleUtils.createPositionsTexture( size , mesh );
        physicsRenderer.reset( pTexture );

        physicsRenderer.debugScene.scale.multiplyScalar( .1 );
        physicsRenderer.debugScene.position.y = 20;
        physicsRenderer.addDebugScene( scene );



        var lineGeo = new THREE.BufferGeometry();

        var lineGeo = new THREE.BufferGeometry();

		lineGeo.addAttribute( 'position', new Float32Array( 32 * 32 * 3 ), 3 );
		lineGeo.addAttribute( 'color'   , new Float32Array( 32 * 32 * 3 ), 3 );
        var positions = lineGeo.getAttribute( 'position' ).array;
        var colors = lineGeo.getAttribute( 'color' ).array;

        var size = 1 / 32;
        var hSize = size / 2;

        for( var i = 0; i < 32; i ++ ){

          var index = i * 3;

          var p1 = index * 2;
          var p2 = index * 2 + 3;

          positions[ p1 ] = 0 * size ;
          positions[ p1 + 1 ] = i * size ;
          positions[ p1 + 2 ] = 1;

          positions[ p2 ] = 0 * size ;
          positions[ p2 + 1 ] = (i + 1) * size;
          positions[ p2 + 2 ] = 1;

          colors[ p1 ]      = .3 ;
          colors[ p1 + 1 ]  = .3;
          colors[ p1 + 2 ]  = .3;

          colors[ p2 ]      = .6;
          colors[ p2 + 1 ]  = .6;
          colors[ p2 + 2 ]  = .6;

          for( var j = 0; j < 4; j++ ){

            // Start these positions after all of our indices
            var startingIndex = 32 * 3;

            var columnStartingIndex = startingIndex + ( 32 * 3 * j);

            var index = (i * 3) + columnStartingIndex;

            var p1 = index * 2;
            var p2 = index * 2 + 3;
            

            positions[ p1 ] = 0 * size;
            positions[ p1 + 1 ] = i * size ;
            positions[ p1 + 2 ] = 1;

            positions[ p2 ]     = ( j + 1) * size;
            positions[ p2 + 1 ] = i  * size;
            positions[ p2 + 2 ] = .1;

            colors[ p1 ]      = .3;
            colors[ p1 + 1 ]  = .3;
            colors[ p1 + 2 ]  = .3;

            colors[ p2 ]      = .6;
            colors[ p2 + 1 ]  = .6;
            colors[ p2 + 2 ]  = .6;

            //positions[ i + 3 ] = Math.random() * 20;
        
          }


          for( var j = 0; j < 3; j ++ ){
            for( var k = 0; k < 4; k++ ){

              var startingIndex = 5 * 32 * 3;
              var groupStartingIndex = startingIndex + ( 32 * 3 * 4 * (j) );
              var columnStartingIndex = groupStartingIndex + ( 32 * 3 * k );

              var index = ( i *3 ) + columnStartingIndex;

              console.log( p1 );
              console.log( p2 );
              
              var p1 = index * 2;
              var p2 = index * 2 + 3;

              positions[ p1 ] = ( j + 1 ) * size;
              positions[ p1 + 1 ] = i * size;
              positions[ p1 + 2 ] = .1;

              positions[ p2 ]     = ( (j * 4) + 5 + k) * size;
              positions[ p2 + 1 ] = i * size;
              positions[ p2 + 2 ] = .1;


              colors[ p1 ]      = Math.floor( (k+1) /4 ) ;
              colors[ p1 + 1 ]  = j / 4;
              colors[ p1 + 2 ]  = 0;

              colors[ p2 ]      = 0;
              colors[ p2 + 1 ]  = j /4 ;
              colors[ p2 + 2 ]  = 0;






            }
          }

        }

        console.log( positions );

        var lineMat = new THREE.LineBasicMaterial({ color:0xffffff });


        var uniforms = {

          lookup:{ type:"t" , value:null }

        }

        var lineMat = new THREE.ShaderMaterial({

          uniforms: uniforms,
          vertexShader: shaders.vertexShaders.lineRender,
          fragmentShader: shaders.fragmentShaders.lineRender

        });


        line = new THREE.Line( lineGeo , lineMat );
        line.type = THREE.LinePieces;


        physicsRenderer.addBoundTexture( line , 'lookup' , 'output' );
        
        scene.add( line );

        var lineGeo = new THREE.BufferGeometry();
        document.addEventListener( 'keydown' , function(e){

          console.log( e.which );
          if( e.which == 32 ){

            paused = !paused;

          }

        });
      }



      function animate(){


        dT.value = clock.getDelta();

        timer += dT.value;
        
        if( !paused ){
          
          leader.x = 20 *  Math.cos( timer);
          leader.y = 20 * Math.sin( timer);
          leader.z = 30 * Math.sin( timer / 1.68);

          physicsRenderer.update();
          
        }

        //physicsRenderer.update();

        requestAnimationFrame( animate );
        controls.update();
        renderer.render( scene , camera );

      }

    </script>

  </body>
</html>

<html>

  <head>
    <style>
      #container{ position:absolute; left:0px; top:0px; z-index:0; width:100%; height:100%; display:block; overflow:hidden}
      body{ margin:0px; }
    </style>
  </head>

  <body>
    <div id="container"></div>


    <script src="../lib/three.js"></script>
    <script src="../lib/jquery.min.js"></script>
    <script src="../lib/TrackballControls.js"></script>
    <script src="../lib/ShaderLoader.js"></script>
    <script src="../lib/dat.gui.min.js"></script>
    
    <script src="../ParticleUtils.js"></script>
    <script src="../PhysicsRenderer.js"></script>

    <script src="js/createLineGeo.js"></script>
    <script src="js/furryTail.js"></script>

    <script>


      var paused = false;


      var camera, renderer, scene , controls , clock;

      var gui = new dat.GUI({});

      var particleSystem;
      var physicsRenderer , uniforms;

      var leader;

      var dT = { type:"f" , value:0 }

      var timer = 0;

      var shaders = new ShaderLoader('../shaders');

      shaders.shaderSetLoaded = function(){
        init();
        animate();
      }

      shaders.load( 'fs-spring' , 'render'  , 'fragment'    );
      shaders.load( 'vs-render' , 'render'  , 'vertex'      );
      shaders.load( 'tailSim'   , 'tailSim' , 'simulation'  );
      shaders.load( 'fs-lineRender' , 'lineRender' , 'fragment' );
      shaders.load( 'vs-lineRender' , 'lineRender' , 'vertex' );


      function init(){

        /*

          THREE.js Initialization

        */

        var w = window.innerWidth;
        var h = window.innerHeight;

        camera = new THREE.PerspectiveCamera( 65 , w/h , 1 , 200000 );
        camera.position.z = 100;

        //controls = new THREE.TrackballControls( camera );
        scene = new THREE.Scene();

        clock = new THREE.Clock();


        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        var container = document.getElementById('container' );
        controls = new THREE.TrackballControls( camera , container );
        container.appendChild( renderer.domElement );


        
        var lineGeo = createLineGeo(); 



        size = 32;

        var sim = shaders.simulationShaders.tailSim;
        physicsRenderer = new PhysicsRenderer( size , sim , renderer ); 

        leader = new THREE.Vector3();

        var mesh = new THREE.Mesh(
          new THREE.IcosahedronGeometry( .5 , 1 ),
          new THREE.MeshNormalMaterial()
        );

        mesh.position = leader;
        scene.add( mesh );


        var leaderU = { type:"v3" , value: leader } 
        physicsRenderer.setUniform( 'leader' , leaderU );
        physicsRenderer.setUniform( 'dT' , dT );


        /*

          Setting up attraction / repulsion uniforms

        */

  
        var dist_spineAttract = { type:"f" , value: 1.1 }
        var force_spineAttract = { type:"f" , value: .1  }

        var dist_bundleAttract = { type:"f" , value: .1 }
        var force_bundleAttract = { type:"f" , value: .4  }
      
        var dist_bundleRepel = { type:"f" , value: 1.1 }
        var force_bundleRepel = { type:"f" , value: .01  }
        
        var dist_subAttract = { type:"f" , value: 1.1 }
        var force_subAttract = { type:"f" , value: .1  }
        
        var dist_subRepel = { type:"f" , value: 3.1 }
        var force_subRepel = { type:"f" , value: .01  }
        
        var dist_subSubAttract = { type:"f" , value: 1.1 }
        var force_subSubAttract = { type:"f" , value: .1  }
        
        var dist_subSubRepel = { type:"f" , value: 3.1 }
        var force_subSubRepel = { type:"f" , value: .01  }


        physicsRenderer.setUniform( 'dist_spineAttract' , dist_spineAttract );
        physicsRenderer.setUniform( 'force_spineAttract' , force_spineAttract );
        
        physicsRenderer.setUniform( 'dist_bundleAttract' , dist_bundleAttract );
        physicsRenderer.setUniform( 'force_bundleAttract' , force_bundleAttract );
        physicsRenderer.setUniform( 'dist_bundleRepel' , dist_bundleRepel );
        physicsRenderer.setUniform( 'force_bundleRepel' , force_bundleRepel );
        
        physicsRenderer.setUniform( 'dist_subAttract' , dist_subAttract );
        physicsRenderer.setUniform( 'force_subAttract' , force_subAttract );
        physicsRenderer.setUniform( 'dist_subRepel' , dist_subRepel );
        physicsRenderer.setUniform( 'force_subRepel' , force_subRepel );
        
        physicsRenderer.setUniform( 'dist_subSubAttract' , dist_subSubAttract );
        physicsRenderer.setUniform( 'force_subSubAttract' , force_subSubAttract );
        physicsRenderer.setUniform( 'dist_subSubRepel' , dist_subSubRepel );
        physicsRenderer.setUniform( 'force_subSubRepel' , force_subSubRepel );

        gui.add( dist_spineAttract, 'value' , 0 , 10 ).name( 'dist_spineAttract' );
        gui.add( force_spineAttract, 'value' , 0 , .5 ).name( 'force_spineAttract' );
        
        gui.add( dist_bundleAttract, 'value' , 0 , 10 ).name( 'dist_bundleAttract' );
        gui.add( force_bundleAttract, 'value' , 0 , .5 ).name( 'force_bundleAttract' );
        gui.add( dist_bundleRepel, 'value' , 0 , 10 ).name( 'dist_bundleRepel' );
        gui.add( force_bundleRepel, 'value' , 0 , .05 ).name( 'force_bundleRepel' );
        
        gui.add( dist_subAttract, 'value'  , 0 , 10  ).name( 'dist_subAttract' );
        gui.add( force_subAttract, 'value' , 0 , .5 ).name( 'force_subAttract' );
        gui.add( dist_subRepel, 'value'  , 0 , 10 ).name( 'dist_subRepel' );
        gui.add( force_subRepel, 'value'  , 0 , .2 ).name( 'force_subRepel' );
        
        gui.add( dist_subSubAttract, 'value'  , 0 , 10 ).name( 'dist_subSubAttract' );
        gui.add( force_subSubAttract, 'value'  , 0 , .5 ).name( 'force_subSubAttract' );
        gui.add( dist_subSubRepel, 'value'  , 0 , 10 ).name( 'dist_subSubRepel' );
        gui.add( force_subSubRepel, 'value' , 0 , .2 ).name( 'force_subSubRepel' );

        uniforms = {
          t_pos:{ type:"t" , value:null },
          t_oPos:{ type:"t" , value:null },
          t_ooPos:{ type:"t" , value:null },
        }

        var mat = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: shaders.vertexShaders.render,
          fragmentShader: shaders.fragmentShaders.render
        })

        var geo = ParticleUtils.createLookupGeometry( size );

        physicsParticles  = new THREE.ParticleSystem( geo , mat );

        physicsRenderer.addBoundTexture( physicsParticles , 't_pos' , 'output' );
        physicsRenderer.addBoundTexture( physicsParticles , 't_oPos' , 'oOutput' );
        physicsRenderer.addBoundTexture( physicsParticles , 't_ooPos' , 'ooOutput' );

        scene.add( physicsParticles );

        var mesh = new THREE.Mesh( new THREE.SphereGeometry( 5 ) );

        var pTexture = ParticleUtils.createPositionsTexture( size , mesh );
        physicsRenderer.reset( pTexture );

        physicsRenderer.debugScene.scale.multiplyScalar( .1 );
        physicsRenderer.debugScene.position.y = 20;
        physicsRenderer.addDebugScene( scene );




        var lineMat = new THREE.LineBasicMaterial({ color:0xffffff });


        var uniforms = {

          lookup:{ type:"t" , value:null }

        }

        var lineMat = new THREE.ShaderMaterial({

          uniforms: uniforms,
          vertexShader: shaders.vertexShaders.lineRender,
          fragmentShader: shaders.fragmentShaders.lineRender

        });


        line = new THREE.Line( lineGeo , lineMat );
        line.type = THREE.LinePieces;


        physicsRenderer.addBoundTexture( line , 'lookup' , 'output' );
        
        scene.add( line );

        var lineGeo = new THREE.BufferGeometry();
        document.addEventListener( 'keydown' , function(e){

          console.log( e.which );
          if( e.which == 32 ){

            paused = !paused;

          }

        });
      }



      function animate(){


        dT.value = clock.getDelta();

        timer += dT.value;
        
        if( !paused ){
          
          leader.x = 20 *  Math.cos( timer);
          leader.y = 20 * Math.sin( timer);
          leader.z = 30 * Math.sin( timer / 1.68);

          physicsRenderer.update();
          
        }

        //physicsRenderer.update();

        requestAnimationFrame( animate );
        controls.update();
        renderer.render( scene , camera );

      }

    </script>

  </body>
</html>
